
MODULE FIELD_4RD_MODULE


USE OML_MOD, ONLY: OML_MAX_THREADS , OML_MY_THREAD
USE IEEE_ARITHMETIC, ONLY: IEEE_SIGNALING_NAN
USE DEV_ALLOC_MODULE
USE FIELD_BASIC_MODULE
USE FIELD_INIT_DEBUG_VALUE_MODULE
USE FIELD_CONSTANTS_MODULE
USE PARKIND1

IMPLICIT NONE

PRIVATE

TYPE, ABSTRACT, EXTENDS (FIELD_BASIC) :: FIELD_4RD
  REAL(KIND=JPRD), POINTER :: PTR(:,:,:,:) => NULL()
  REAL(KIND=JPRD), POINTER, CONTIGUOUS :: DEVPTR(:,:,:,:) => NULL()
CONTAINS

  PROCEDURE :: FINAL => FIELD_4RD_FINAL
  PROCEDURE :: FIELD_4RD_FINAL
  PROCEDURE :: DELETE_DEVICE_DATA => FIELD_4RD_DELETE_DEVICE_DATA
  PROCEDURE :: GET_VIEW => FIELD_4RD_GET_VIEW
  PROCEDURE :: GET_DEVICE_DATA_RDONLY => FIELD_4RD_GET_DEVICE_DATA_RDONLY
  PROCEDURE :: GET_DEVICE_DATA_RDWR => FIELD_4RD_GET_DEVICE_DATA_RDWR
  PROCEDURE :: GET_HOST_DATA_RDONLY => FIELD_4RD_GET_HOST_DATA_RDONLY
  PROCEDURE :: GET_HOST_DATA_RDWR => FIELD_4RD_GET_HOST_DATA_RDWR
  PROCEDURE :: SYNC_HOST_RDWR => FIELD_4RD_SYNC_HOST_RDWR
  PROCEDURE :: SYNC_HOST_RDONLY => FIELD_4RD_SYNC_HOST_RDONLY
  PROCEDURE :: SYNC_DEVICE_RDWR => FIELD_4RD_SYNC_DEVICE_RDWR
  PROCEDURE :: SYNC_DEVICE_RDONLY => FIELD_4RD_SYNC_DEVICE_RDONLY
  PROCEDURE :: COPY_OBJECT => FIELD_4RD_COPY_OBJECT
  PROCEDURE :: WIPE_OBJECT => FIELD_4RD_WIPE_OBJECT
  PROCEDURE(GET_DIMS), DEFERRED :: GET_DIMS
  PROCEDURE(RESIZE), DEFERRED :: RESIZE

  PROCEDURE, PRIVATE :: GET_DEVICE_DATA => FIELD_4RD_GET_DEVICE_DATA
  PROCEDURE, PRIVATE :: GET_HOST_DATA => FIELD_4RD_GET_HOST_DATA
  PROCEDURE, PRIVATE :: FIELD_4RD_GET_HOST_DATA
  PROCEDURE, PRIVATE :: FIELD_4RD_GET_DEVICE_DATA
  PROCEDURE, PRIVATE :: COPY_DATA =>  FIELD_4RD_COPY_DATA
  PROCEDURE :: CREATE_DEVICE_DATA => FIELD_4RD_CREATE_DEVICE_DATA
END TYPE FIELD_4RD

ABSTRACT INTERFACE
  SUBROUTINE GET_DIMS(SELF, LBOUNDS, UBOUNDS)
    USE PARKIND1
    IMPORT ::  FIELD_4RD
    CLASS(FIELD_4RD),               INTENT(IN) :: SELF
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(OUT) :: LBOUNDS(4)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(OUT) :: UBOUNDS(4)
  END SUBROUTINE GET_DIMS
  SUBROUTINE RESIZE (SELF, UBOUNDS, LBOUNDS, PERSISTENT)
    USE PARKIND1
    IMPORT ::  FIELD_4RD
    CLASS(FIELD_4RD),               INTENT(IN) :: SELF
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: UBOUNDS(4)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: LBOUNDS(4)
    LOGICAL, OPTIONAL,            INTENT(IN) :: PERSISTENT
  END SUBROUTINE RESIZE
END INTERFACE

PUBLIC :: FIELD_4RD

TYPE, EXTENDS(FIELD_4RD) :: FIELD_4RD_WRAPPER
CONTAINS
  PROCEDURE :: INIT => FIELD_4RD_WRAPPER_INIT
  PROCEDURE :: FINAL => FIELD_4RD_WRAPPER_FINAL
  PROCEDURE :: GET_DIMS => FIELD_4RD_WRAPPER_GET_DIMS
  PROCEDURE :: RESIZE => FIELD_4RD_WRAPPER_RESIZE
END TYPE FIELD_4RD_WRAPPER

PUBLIC :: FIELD_4RD_WRAPPER

TYPE, EXTENDS(FIELD_4RD) :: FIELD_4RD_OWNER
  INTEGER(KIND=JPIM) :: LBOUNDS(4), UBOUNDS(4)
  LOGICAL :: HAS_INIT_VALUE = .FALSE.
  REAL(KIND=JPRD) :: INIT_VALUE
CONTAINS
  PROCEDURE :: INIT => FIELD_4RD_OWNER_INIT
  PROCEDURE :: FINAL => FIELD_4RD_OWNER_FINAL
  PROCEDURE, PRIVATE :: ALLOCATE => FIELD_4RD_ALLOCATE
  PROCEDURE, PRIVATE :: GET_HOST_DATA => FIELD_4RD_OWNER_GET_HOST_DATA
  PROCEDURE, PRIVATE :: GET_DEVICE_DATA => FIELD_4RD_OWNER_GET_DEVICE_DATA
  PROCEDURE :: GET_DIMS => FIELD_4RD_OWNER_GET_DIMS
  PROCEDURE :: RESIZE => FIELD_4RD_OWNER_RESIZE
END TYPE FIELD_4RD_OWNER

PUBLIC :: FIELD_4RD_OWNER

TYPE FIELD_4RD_PTR
  CLASS(FIELD_4RD), POINTER :: PTR => NULL()
END TYPE FIELD_4RD_PTR

PUBLIC :: FIELD_4RD_PTR

TYPE FIELD_4RD_VIEW
  REAL(KIND=JPRD), POINTER :: P(:,:,:) => NULL()
END TYPE FIELD_4RD_VIEW

PUBLIC :: FIELD_4RD_VIEW


CONTAINS

  SUBROUTINE FIELD_4RD_WRAPPER_INIT(SELF, DATA, PERSISTENT, LBOUNDS)
    ! Create FIELD object by wrapping existing data
    CLASS(FIELD_4RD_WRAPPER) :: SELF
    REAL(KIND=JPRD), TARGET, INTENT(IN) :: DATA(:,:,:,:)
    LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(4)
    LOGICAL :: LLPERSISTENT

    LLPERSISTENT = .TRUE.
    IF (PRESENT (PERSISTENT)) LLPERSISTENT = PERSISTENT

    IF (PRESENT(LBOUNDS)) THEN
      SELF%PTR(LBOUNDS(1):, LBOUNDS(2):, LBOUNDS(3):, LBOUNDS(4):) => DATA
    ELSE
      SELF%PTR => DATA
    ENDIF
    SELF%THREAD_BUFFER = .NOT. LLPERSISTENT
    CALL SELF%SET_STATUS (NHSTFRESH)

    IF (.NOT. LLPERSISTENT) THEN
      IF (OML_MAX_THREADS () /= SIZE (DATA, 4)) THEN
        CALL ABOR1 ('FIELD_4RD_WRAPPER_INIT: DIMENSION MISMATCH')
      ENDIF
    ENDIF

  END SUBROUTINE FIELD_4RD_WRAPPER_INIT

  SUBROUTINE FIELD_4RD_OWNER_INIT (SELF, LBOUNDS, UBOUNDS, PERSISTENT, DELAYED, INIT_VALUE)
    CLASS(FIELD_4RD_OWNER) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(4)
    INTEGER(KIND=JPIM), INTENT(IN) :: UBOUNDS(4)
    LOGICAL, OPTIONAL,  INTENT(IN) :: PERSISTENT
    LOGICAL, OPTIONAL,  INTENT(IN) :: DELAYED
    REAL(KIND=JPRD), OPTIONAL, INTENT(IN) :: INIT_VALUE
    LOGICAL :: IS_DELAYED

    IS_DELAYED = .FALSE.
    IF(PRESENT(DELAYED))THEN
      IS_DELAYED = DELAYED
    ENDIF

    IF (PRESENT (LBOUNDS)) THEN
      SELF%LBOUNDS=LBOUNDS
    ELSE
      SELF%LBOUNDS=1
    ENDIF
    SELF%UBOUNDS=UBOUNDS
    SELF%UBOUNDS(4) = OML_MAX_THREADS ()

    ! By default we allocate thread-local temporaries
    SELF%THREAD_BUFFER = .TRUE.

    SELF%LAST_CONTIGUOUS_DIMENSION = 4

    IF (PRESENT(PERSISTENT)) THEN
      IF (PERSISTENT) THEN
        SELF%THREAD_BUFFER = .FALSE.
        SELF%LBOUNDS(4) = 1
        SELF%UBOUNDS(4) = UBOUNDS(4)
      END IF
    END IF

    CALL SELF%SET_STATUS (UNALLOCATED)
    IF (PRESENT(INIT_VALUE)) THEN
      SELF%HAS_INIT_VALUE=.TRUE.
      SELF%INIT_VALUE=INIT_VALUE
    ELSE IF(USE_INIT_DEBUG_VALUE) THEN
      SELF%HAS_INIT_VALUE=.TRUE.
      SELF%INIT_VALUE=INIT_DEBUG_VALUE_JPRD
    ENDIF
    IF(.NOT. IS_DELAYED) THEN
      CALL SELF%ALLOCATE()
      IF (SELF%HAS_INIT_VALUE) THEN
        SELF%PTR=SELF%INIT_VALUE
        CALL SELF%SET_STATUS (NHSTFRESH)
      ENDIF
    ENDIF
  END SUBROUTINE FIELD_4RD_OWNER_INIT

  SUBROUTINE FIELD_4RD_ALLOCATE (SELF)
    ! Create FIELD object by explicitly allocating new data
    CLASS(FIELD_4RD_OWNER) :: SELF

    ALLOCATE(SELF%PTR(SELF%LBOUNDS(1):SELF%UBOUNDS(1), SELF%LBOUNDS(2):SELF%UBOUNDS(2), SELF%LBOUNDS(3):SELF%UBOUNDS(3),&
        & SELF%LBOUNDS(4):SELF%UBOUNDS(4)))
    CALL SELF%SET_STATUS (UNINITIALIZED)
  END SUBROUTINE FIELD_4RD_ALLOCATE

  FUNCTION FIELD_4RD_GET_VIEW(SELF, BLOCK_INDEX, ZERO) RESULT(VIEW_PTR)
    CLASS(FIELD_4RD) :: SELF
    REAL(KIND=JPRD), POINTER :: VIEW_PTR(:,:,:)
    INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
    LOGICAL, OPTIONAL,  INTENT(IN) :: ZERO
    INTEGER(KIND=JPIM) :: IDX
    INTEGER(KIND=JPIM) :: LBOUNDS(4)
#include "abor1.intfb.h"

    IF(IAND (SELF%ISTATUS,NHSTFRESH) /= NHSTFRESH) THEN
      CALL ABOR1 ("GET_VIEW WAS CALLED, BUT DATA IS NOT PRESENT ON HOST")
    ENDIF

    IDX = BLOCK_INDEX
    IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD ()

    LBOUNDS=LBOUND(SELF%PTR)
    VIEW_PTR(LBOUNDS(1):,LBOUNDS(2):,LBOUNDS(3):) => SELF%PTR(:,:,:,IDX)

    IF (PRESENT(ZERO)) THEN
      IF (ZERO) VIEW_PTR(:,:,:) = 0.0_JPRD
    END IF

    IF (ASSOCIATED (SELF%PARENT)) THEN
      CALL SELF%PARENT%SET_DEVICE_DIRTY ()
    ELSE
! Mark data dirty on the device: the pointer returned by GET_VIEW may be rw
      CALL SELF%SET_DEVICE_DIRTY ()
    ENDIF

  END FUNCTION FIELD_4RD_GET_VIEW

  SUBROUTINE FIELD_4RD_DELETE_DEVICE_DATA(SELF)
    ! Delete the copy of this field on GPU device
    CLASS(FIELD_4RD) :: SELF

    IF (ASSOCIATED (SELF%PARENT)) THEN
      CALL SELF%PARENT%DELETE_DEVICE_DATA ()
    ELSEIF (ASSOCIATED (SELF%DEVPTR)) THEN
      CALL DEV_DEALLOCATE (SELF%DEVPTR)
    ENDIF
  END SUBROUTINE FIELD_4RD_DELETE_DEVICE_DATA

  SUBROUTINE FIELD_4RD_FINAL(SELF)
    ! Finalizes field and deallocates owned data
    CLASS(FIELD_4RD) :: SELF
    NULLIFY(SELF%PTR)
    CALL SELF%DELETE_DEVICE_DATA()
  END SUBROUTINE FIELD_4RD_FINAL

  SUBROUTINE FIELD_4RD_WRAPPER_FINAL(SELF)
    ! Finalizes field and deallocates owned data
    CLASS(FIELD_4RD_WRAPPER) :: SELF
    REAL(KIND=JPRD), POINTER :: PTR(:,:,:,:)
    CALL SELF%GET_HOST_DATA_RDONLY(PTR)
    CALL SELF%FIELD_4RD_FINAL
  END SUBROUTINE FIELD_4RD_WRAPPER_FINAL

  SUBROUTINE FIELD_4RD_OWNER_FINAL(SELF)
    ! Finalizes field and deallocates owned data
    CLASS(FIELD_4RD_OWNER) :: SELF
    IF (ASSOCIATED(SELF%PTR)) THEN
      DEALLOCATE(SELF%PTR)
    END IF
    CALL SELF%FIELD_4RD_FINAL
  END SUBROUTINE FIELD_4RD_OWNER_FINAL

  SUBROUTINE FIELD_4RD_COPY_OBJECT (SELF, LDCREATED)
  CLASS(FIELD_4RD) :: SELF
  LOGICAL, INTENT (IN), OPTIONAL :: LDCREATED
#include "abor1.intfb.h"
  LOGICAL :: LLCREATED

  LLCREATED = .FALSE.
  IF (PRESENT (LDCREATED)) LLCREATED = LDCREATED

  IF (.NOT. LLCREATED) CALL ABOR1 ('FIELD_4RD_COPY_OBJECT: OBJECT WAS NOT CREATED')

  IF (.NOT. SELF%LOBJECT_COPIED) THEN
    SELF%LOBJECT_COPIED = .TRUE.
#ifdef _OPENACC
    IF (ASSOCIATED (SELF%DEVPTR)) THEN
      !$acc enter data attach (SELF%DEVPTR)
    ENDIF
#endif
  ENDIF

  END SUBROUTINE FIELD_4RD_COPY_OBJECT

  SUBROUTINE FIELD_4RD_WIPE_OBJECT (SELF, LDDELETED)
  CLASS(FIELD_4RD) :: SELF
  LOGICAL, INTENT (IN), OPTIONAL :: LDDELETED
#include "abor1.intfb.h"
  LOGICAL :: LLDELETED

  LLDELETED = .FALSE.
  IF (PRESENT (LDDELETED)) LLDELETED = LDDELETED

  IF (.NOT. LLDELETED) CALL ABOR1 ('FIELD_4RD_WIPE_OBJECT: OBJECT WAS NOT DELETED')

  IF (SELF%LOBJECT_COPIED) THEN
    SELF%LOBJECT_COPIED = .FALSE.
#ifdef _OPENACC
    IF (ASSOCIATED (SELF%DEVPTR)) THEN
      !$acc exit data detach (SELF%DEVPTR)
    ENDIF
#endif
  ENDIF

  END SUBROUTINE FIELD_4RD_WIPE_OBJECT

  SUBROUTINE FIELD_4RD_COPY_DATA (SELF, KDIR, QUEUE)
  CLASS(FIELD_4RD) :: SELF
  INTEGER (KIND=JPIM),           INTENT(IN) :: KDIR
  INTEGER (KIND=JPIM), OPTIONAL, INTENT(IN) :: QUEUE
  REAL :: START, FINISH

  SELF%LAST_CONTIGUOUS_DIMENSION = FIELD_4RD_GET_LAST_CONTIGUOUS_DIMENSION (SELF%PTR)

  CALL CPU_TIME(START)
  SELECT CASE (SELF%LAST_CONTIGUOUS_DIMENSION)
    CASE (0)
      CALL COPY_DIM0_CONTIGUOUS (SELF%PTR, SELF%DEVPTR, KDIR, QUEUE)
    CASE (1)
      CALL COPY_DIM1_CONTIGUOUS (SELF%PTR, SELF%DEVPTR, KDIR, QUEUE)
    CASE (2)
      CALL COPY_DIM2_CONTIGUOUS (SELF%PTR, SELF%DEVPTR, KDIR, QUEUE)
    CASE (3)
      CALL COPY_DIM3_CONTIGUOUS (SELF%PTR, SELF%DEVPTR, KDIR, QUEUE)
    CASE (4)
      CALL COPY_DIM4_CONTIGUOUS (SELF%PTR, SELF%DEVPTR, KDIR, QUEUE)
  END SELECT
  CALL CPU_TIME(FINISH)
  IF (KDIR == NH2D) THEN
    CALL SELF%STATS%INC_CPU_TO_GPU_TRANSFER(START, FINISH)
  ELSE IF (KDIR == ND2H) THEN
    CALL SELF%STATS%INC_GPU_TO_CPU_TRANSFER(START, FINISH)
  END IF

  CONTAINS

    SUBROUTINE COPY_DIM0_CONTIGUOUS (HST, DEV, KDIR, QUEUE)
#ifdef _OPENACC
    USE OPENACC
#endif
    REAL(KIND=JPRD), POINTER :: HST (:,:,:,:), DEV (:,:,:,:)
    INTEGER (KIND=JPIM),           INTENT (IN) :: KDIR
    INTEGER (KIND=JPIM), OPTIONAL, INTENT (IN) :: QUEUE
    INTEGER (KIND=JPIM) :: ISIZE
    INTEGER :: J, J1, J2, J3, J4

    DO J4 = LBOUND (HST, 4), UBOUND (HST, 4)
      DO J3 = LBOUND (HST, 3), UBOUND (HST, 3)
        DO J2 = LBOUND (HST, 2), UBOUND (HST, 2)
          DO J1 = LBOUND (HST, 1), UBOUND (HST, 1)
            ISIZE = KIND (HST)
            IF (KDIR == NH2D) THEN
#ifdef _OPENACC
              !$acc host_data use_device (DEV)
              IF(PRESENT(QUEUE))THEN
                CALL ACC_MEMCPY_TO_DEVICE_ASYNC (DEV (J1, J2, J3, J4), HST (J1, J2, J3, J4), ISIZE, QUEUE)
              ELSE
                CALL ACC_MEMCPY_TO_DEVICE (DEV (J1, J2, J3, J4), HST (J1, J2, J3, J4), ISIZE)
              ENDIF
              !$acc end host_data
#else
              DEV (J1, J2, J3, J4) = HST (J1, J2, J3, J4)
#endif
            ELSEIF (KDIR == ND2H) THEN
#ifdef _OPENACC
              !$acc host_data use_device (DEV)
              IF(PRESENT(QUEUE))THEN
                CALL ACC_MEMCPY_FROM_DEVICE_ASYNC (HST (J1, J2, J3, J4), DEV (J1, J2, J3, J4), ISIZE, QUEUE)
              ELSE
                CALL ACC_MEMCPY_FROM_DEVICE (HST (J1, J2, J3, J4), DEV (J1, J2, J3, J4), ISIZE)
              ENDIF
              !$acc end host_data
#else
              HST (J1, J2, J3, J4) = DEV (J1, J2, J3, J4)
#endif
            ENDIF
          ENDDO
        ENDDO
      ENDDO
    ENDDO
    END SUBROUTINE

    SUBROUTINE COPY_DIM1_CONTIGUOUS (HST, DEV, KDIR, QUEUE)
#ifdef _OPENACC
    USE OPENACC
#endif
    REAL(KIND=JPRD), POINTER :: HST (:,:,:,:), DEV (:,:,:,:)
    INTEGER (KIND=JPIM),           INTENT (IN) :: KDIR
    INTEGER (KIND=JPIM), OPTIONAL, INTENT (IN) :: QUEUE
    INTEGER (KIND=JPIM) :: ISIZE
    INTEGER :: J, J2, J3, J4

    DO J4 = LBOUND (HST, 4), UBOUND (HST, 4)
      DO J3 = LBOUND (HST, 3), UBOUND (HST, 3)
        DO J2 = LBOUND (HST, 2), UBOUND (HST, 2)
          ISIZE = KIND (HST) * SIZE (HST (:, J2, J3, J4))
          IF (KDIR == NH2D) THEN
#ifdef _OPENACC
            !$acc host_data use_device (DEV)
            IF(PRESENT(QUEUE))THEN
              CALL ACC_MEMCPY_TO_DEVICE_ASYNC (DEV (:, J2, J3, J4), HST (:, J2, J3, J4), ISIZE, QUEUE)
            ELSE
              CALL ACC_MEMCPY_TO_DEVICE (DEV (:, J2, J3, J4), HST (:, J2, J3, J4), ISIZE)
            ENDIF
            !$acc end host_data
#else
            DEV (:, J2, J3, J4) = HST (:, J2, J3, J4)
#endif
          ELSEIF (KDIR == ND2H) THEN
#ifdef _OPENACC
            !$acc host_data use_device (DEV)
            IF(PRESENT(QUEUE))THEN
              CALL ACC_MEMCPY_FROM_DEVICE_ASYNC (HST (:, J2, J3, J4), DEV (:, J2, J3, J4), ISIZE, QUEUE)
            ELSE
              CALL ACC_MEMCPY_FROM_DEVICE (HST (:, J2, J3, J4), DEV (:, J2, J3, J4), ISIZE)
            ENDIF
            !$acc end host_data
#else
            HST (:, J2, J3, J4) = DEV (:, J2, J3, J4)
#endif
          ENDIF
        ENDDO
      ENDDO
    ENDDO
    END SUBROUTINE

    SUBROUTINE COPY_DIM2_CONTIGUOUS (HST, DEV, KDIR, QUEUE)
#ifdef _OPENACC
    USE OPENACC
#endif
    REAL(KIND=JPRD), POINTER :: HST (:,:,:,:), DEV (:,:,:,:)
    INTEGER (KIND=JPIM),           INTENT (IN) :: KDIR
    INTEGER (KIND=JPIM), OPTIONAL, INTENT (IN) :: QUEUE
    INTEGER (KIND=JPIM) :: ISIZE
    INTEGER :: J, J3, J4

    DO J4 = LBOUND (HST, 4), UBOUND (HST, 4)
      DO J3 = LBOUND (HST, 3), UBOUND (HST, 3)
        ISIZE = KIND (HST) * SIZE (HST (:, :, J3, J4))
        IF (KDIR == NH2D) THEN
#ifdef _OPENACC
          !$acc host_data use_device (DEV)
          IF(PRESENT(QUEUE))THEN
            CALL ACC_MEMCPY_TO_DEVICE_ASYNC (DEV (:, :, J3, J4), HST (:, :, J3, J4), ISIZE, QUEUE)
          ELSE
            CALL ACC_MEMCPY_TO_DEVICE (DEV (:, :, J3, J4), HST (:, :, J3, J4), ISIZE)
          ENDIF
          !$acc end host_data
#else
          DEV (:, :, J3, J4) = HST (:, :, J3, J4)
#endif
        ELSEIF (KDIR == ND2H) THEN
#ifdef _OPENACC
          !$acc host_data use_device (DEV)
          IF(PRESENT(QUEUE))THEN
            CALL ACC_MEMCPY_FROM_DEVICE_ASYNC (HST (:, :, J3, J4), DEV (:, :, J3, J4), ISIZE, QUEUE)
          ELSE
            CALL ACC_MEMCPY_FROM_DEVICE (HST (:, :, J3, J4), DEV (:, :, J3, J4), ISIZE)
          ENDIF
          !$acc end host_data
#else
          HST (:, :, J3, J4) = DEV (:, :, J3, J4)
#endif
        ENDIF
      ENDDO
    ENDDO
    END SUBROUTINE

    SUBROUTINE COPY_DIM3_CONTIGUOUS (HST, DEV, KDIR, QUEUE)
#ifdef _OPENACC
    USE OPENACC
#endif
    REAL(KIND=JPRD), POINTER :: HST (:,:,:,:), DEV (:,:,:,:)
    INTEGER (KIND=JPIM),           INTENT (IN) :: KDIR
    INTEGER (KIND=JPIM), OPTIONAL, INTENT (IN) :: QUEUE
    INTEGER (KIND=JPIM) :: ISIZE
    INTEGER :: J, J4

    DO J4 = LBOUND (HST, 4), UBOUND (HST, 4)
      ISIZE = KIND (HST) * SIZE (HST (:, :, :, J4))
      IF (KDIR == NH2D) THEN
#ifdef _OPENACC
        !$acc host_data use_device (DEV)
        IF(PRESENT(QUEUE))THEN
          CALL ACC_MEMCPY_TO_DEVICE_ASYNC (DEV (:, :, :, J4), HST (:, :, :, J4), ISIZE, QUEUE)
        ELSE
          CALL ACC_MEMCPY_TO_DEVICE (DEV (:, :, :, J4), HST (:, :, :, J4), ISIZE)
        ENDIF
        !$acc end host_data
#else
        DEV (:, :, :, J4) = HST (:, :, :, J4)
#endif
      ELSEIF (KDIR == ND2H) THEN
#ifdef _OPENACC
        !$acc host_data use_device (DEV)
        IF(PRESENT(QUEUE))THEN
          CALL ACC_MEMCPY_FROM_DEVICE_ASYNC (HST (:, :, :, J4), DEV (:, :, :, J4), ISIZE, QUEUE)
        ELSE
          CALL ACC_MEMCPY_FROM_DEVICE (HST (:, :, :, J4), DEV (:, :, :, J4), ISIZE)
        ENDIF
        !$acc end host_data
#else
        HST (:, :, :, J4) = DEV (:, :, :, J4)
#endif
      ENDIF
    ENDDO
    END SUBROUTINE

    SUBROUTINE COPY_DIM4_CONTIGUOUS (HST, DEV, KDIR, QUEUE)
#ifdef _OPENACC
    USE OPENACC
#endif
    REAL(KIND=JPRD), POINTER :: HST (:,:,:,:), DEV (:,:,:,:)
    INTEGER (KIND=JPIM),           INTENT (IN) :: KDIR
    INTEGER (KIND=JPIM), OPTIONAL, INTENT (IN) :: QUEUE
    INTEGER (KIND=JPIM) :: ISIZE
    INTEGER :: J

        ISIZE = KIND (HST) * SIZE (HST (:, :, :, :))
        IF (KDIR == NH2D) THEN
#ifdef _OPENACC
          !$acc host_data use_device (DEV)
          IF(PRESENT(QUEUE))THEN
            CALL ACC_MEMCPY_TO_DEVICE_ASYNC (DEV (:, :, :, :), HST (:, :, :, :), ISIZE, QUEUE)
          ELSE
            CALL ACC_MEMCPY_TO_DEVICE (DEV (:, :, :, :), HST (:, :, :, :), ISIZE)
          ENDIF
          !$acc end host_data
#else
          DEV (:, :, :, :) = HST (:, :, :, :)
#endif
        ELSEIF (KDIR == ND2H) THEN
#ifdef _OPENACC
          !$acc host_data use_device (DEV)
          IF(PRESENT(QUEUE))THEN
            CALL ACC_MEMCPY_FROM_DEVICE_ASYNC (HST (:, :, :, :), DEV (:, :, :, :), ISIZE, QUEUE)
          ELSE
            CALL ACC_MEMCPY_FROM_DEVICE (HST (:, :, :, :), DEV (:, :, :, :), ISIZE)
          ENDIF
          !$acc end host_data
#else
          HST (:, :, :, :) = DEV (:, :, :, :)
#endif
        ENDIF
    END SUBROUTINE


  END SUBROUTINE FIELD_4RD_COPY_DATA


  SUBROUTINE FIELD_4RD_GET_HOST_DATA (SELF, MODE, PTR, QUEUE)
    CLASS(FIELD_4RD) :: SELF
    INTEGER (KIND=JPIM),           INTENT(IN)    :: MODE

    REAL(KIND=JPRD), POINTER,          INTENT(INOUT) :: PTR(:,:,:,:)
    INTEGER (KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE

    INTEGER(KIND=JPIM) :: LBOUNDS(4)

    LBOUNDS=LBOUND(SELF%PTR)
    IF (IAND (SELF%ISTATUS, NHSTFRESH) == 0) THEN
      CALL SELF%COPY_DATA (ND2H, QUEUE)
      CALL SELF%SET_STATUS (IOR (SELF%ISTATUS, NHSTFRESH))
    ENDIF
    PTR (LBOUNDS(1):, LBOUNDS(2):, LBOUNDS(3):, LBOUNDS(4):) => SELF%PTR (:,:,:,:)
    IF (IAND (MODE, NWR) /= 0) THEN
      CALL SELF%SET_STATUS (IAND (SELF%ISTATUS, NOT (NDEVFRESH)))
    ENDIF

  END SUBROUTINE FIELD_4RD_GET_HOST_DATA

  SUBROUTINE FIELD_4RD_OWNER_GET_HOST_DATA (SELF, MODE, PTR, QUEUE)
    CLASS(FIELD_4RD_OWNER) :: SELF
    INTEGER (KIND=JPIM),           INTENT(IN)    :: MODE
    REAL(KIND=JPRD), POINTER,          INTENT(INOUT) :: PTR(:,:,:,:)
    INTEGER (KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE

    IF(SELF%ISTATUS==UNALLOCATED)THEN
      CALL SELF%ALLOCATE()
      IF (SELF%HAS_INIT_VALUE) THEN
        SELF%PTR=SELF%INIT_VALUE
        CALL SELF%SET_STATUS (NHSTFRESH)
      ENDIF
    ENDIF
    CALL SELF%FIELD_4RD_GET_HOST_DATA(MODE, PTR, QUEUE)

  END SUBROUTINE FIELD_4RD_OWNER_GET_HOST_DATA

  SUBROUTINE FIELD_4RD_GET_HOST_DATA_RDONLY (SELF, PPTR, QUEUE)
    CLASS(FIELD_4RD) :: SELF
    REAL(KIND=JPRD), POINTER,         INTENT(INOUT) :: PPTR(:,:,:,:)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE

    IF (ASSOCIATED (SELF%PARENT)) THEN
      CALL SELF%PARENT%SYNC_HOST_RDONLY (QUEUE)
    ENDIF

    CALL SELF%GET_HOST_DATA (NRD, PPTR, QUEUE)

  END SUBROUTINE FIELD_4RD_GET_HOST_DATA_RDONLY

  SUBROUTINE FIELD_4RD_SYNC_HOST_RDONLY (SELF, QUEUE)
    CLASS(FIELD_4RD) :: SELF
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE
    REAL(KIND=JPRD), POINTER                        :: ZPTR(:,:,:,:)

    IF (ASSOCIATED (SELF%PARENT)) THEN
      CALL SELF%PARENT%SYNC_HOST_RDONLY (QUEUE)
    ENDIF

    CALL SELF%GET_HOST_DATA_RDONLY (ZPTR, QUEUE)

  END SUBROUTINE FIELD_4RD_SYNC_HOST_RDONLY

  SUBROUTINE FIELD_4RD_GET_HOST_DATA_RDWR (SELF, PPTR, QUEUE)
    CLASS(FIELD_4RD) :: SELF
    REAL(KIND=JPRD), POINTER,         INTENT(INOUT) :: PPTR(:,:,:,:)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE

    IF (ASSOCIATED (SELF%PARENT)) THEN
      CALL SELF%PARENT%SYNC_HOST_RDWR (QUEUE)
    ENDIF

    CALL SELF%GET_HOST_DATA (IOR (NRD, NWR), PPTR, QUEUE)

  END SUBROUTINE FIELD_4RD_GET_HOST_DATA_RDWR

  SUBROUTINE FIELD_4RD_SYNC_HOST_RDWR (SELF, QUEUE)
    CLASS(FIELD_4RD) :: SELF
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE
    REAL(KIND=JPRD), POINTER                        :: ZPTR(:,:,:,:)

    IF (ASSOCIATED (SELF%PARENT)) THEN
      CALL SELF%PARENT%SYNC_HOST_RDWR (QUEUE)
    ENDIF

    CALL SELF%GET_HOST_DATA_RDWR (ZPTR, QUEUE)

  END SUBROUTINE FIELD_4RD_SYNC_HOST_RDWR

  SUBROUTINE FIELD_4RD_CREATE_DEVICE_DATA (SELF)
    CLASS(FIELD_4RD) :: SELF
    IF (ASSOCIATED (SELF%PARENT)) THEN
      CALL SELF%PARENT%CREATE_DEVICE_DATA ()
    ELSE
      CALL DEV_ALLOCATE_HST (DEV=SELF%DEVPTR, HST=SELF%PTR)
    ENDIF
  END SUBROUTINE

  SUBROUTINE FIELD_4RD_GET_DEVICE_DATA (SELF, MODE, PTR, QUEUE)
    CLASS(FIELD_4RD) :: SELF
    INTEGER (KIND=JPIM),           INTENT(IN)    :: MODE
    REAL(KIND=JPRD), POINTER,          INTENT(INOUT) :: PTR(:,:,:,:)
    INTEGER (KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE
    INTEGER(KIND=JPIM)                           :: LBOUNDS(4)

    LBOUNDS=LBOUND(SELF%PTR)
    IF (.NOT. ASSOCIATED (SELF%DEVPTR)) THEN
      CALL SELF%CREATE_DEVICE_DATA
    ENDIF
    IF (IAND (SELF%ISTATUS, NDEVFRESH) == 0) THEN
      CALL SELF%COPY_DATA (NH2D, QUEUE)
      CALL SELF%SET_STATUS (IOR (SELF%ISTATUS, NDEVFRESH))
    ENDIF
    PTR (LBOUNDS(1):, LBOUNDS(2):, LBOUNDS(3):, LBOUNDS(4):) => SELF%DEVPTR (:,:,:,:)
    IF (IAND (MODE, NWR) /= 0) THEN
      CALL SELF%SET_STATUS (IAND (SELF%ISTATUS, NOT (NHSTFRESH)))
    ENDIF

  END SUBROUTINE FIELD_4RD_GET_DEVICE_DATA

  SUBROUTINE FIELD_4RD_OWNER_GET_DEVICE_DATA (SELF, MODE, PTR, QUEUE)
    CLASS(FIELD_4RD_OWNER) :: SELF
    INTEGER (KIND=JPIM),           INTENT(IN)    :: MODE
    REAL(KIND=JPRD), POINTER,          INTENT(INOUT) :: PTR(:,:,:,:)
    INTEGER (KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE

    IF(SELF%ISTATUS==UNALLOCATED)THEN
      CALL SELF%ALLOCATE()
      IF (SELF%HAS_INIT_VALUE) THEN
        CALL SELF%CREATE_DEVICE_DATA
        SELF%PTR=SELF%INIT_VALUE
        CALL SELF%SET_STATUS (NHSTFRESH)
      ENDIF
    ENDIF
    CALL SELF%FIELD_4RD_GET_DEVICE_DATA(MODE, PTR, QUEUE)

  END SUBROUTINE FIELD_4RD_OWNER_GET_DEVICE_DATA

  SUBROUTINE FIELD_4RD_GET_DEVICE_DATA_RDONLY (SELF, PPTR, QUEUE)
    CLASS(FIELD_4RD) :: SELF
    REAL(KIND=JPRD), POINTER,         INTENT(INOUT) :: PPTR(:,:,:,:)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE

    IF (ASSOCIATED (SELF%PARENT)) THEN
      CALL SELF%PARENT%SYNC_DEVICE_RDONLY (QUEUE)
    ENDIF

    CALL SELF%GET_DEVICE_DATA (NRD, PPTR, QUEUE)

  END SUBROUTINE FIELD_4RD_GET_DEVICE_DATA_RDONLY

  SUBROUTINE FIELD_4RD_SYNC_DEVICE_RDONLY (SELF, QUEUE)
    CLASS(FIELD_4RD) :: SELF
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE
    REAL(KIND=JPRD), POINTER                        :: ZPTR(:,:,:,:)

    IF (ASSOCIATED (SELF%PARENT)) THEN
      CALL SELF%PARENT%SYNC_DEVICE_RDONLY (QUEUE)
    ENDIF

    CALL SELF%GET_DEVICE_DATA_RDONLY (ZPTR, QUEUE)

  END SUBROUTINE FIELD_4RD_SYNC_DEVICE_RDONLY

  SUBROUTINE FIELD_4RD_GET_DEVICE_DATA_RDWR (SELF, PPTR, QUEUE)
    CLASS(FIELD_4RD) :: SELF
    REAL(KIND=JPRD), POINTER,         INTENT(INOUT) :: PPTR(:,:,:,:)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE

    IF (ASSOCIATED (SELF%PARENT)) THEN
      CALL SELF%PARENT%SYNC_DEVICE_RDWR (QUEUE)
    ENDIF

    CALL SELF%GET_DEVICE_DATA (IOR (NRD, NWR), PPTR, QUEUE)

  END SUBROUTINE FIELD_4RD_GET_DEVICE_DATA_RDWR

  SUBROUTINE FIELD_4RD_SYNC_DEVICE_RDWR (SELF, QUEUE)
    CLASS(FIELD_4RD) :: SELF
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE
    REAL(KIND=JPRD), POINTER                        :: ZPTR(:,:,:,:)

    CALL SELF%GET_DEVICE_DATA_RDWR (ZPTR, QUEUE)

  END SUBROUTINE FIELD_4RD_SYNC_DEVICE_RDWR

  SUBROUTINE FIELD_4RD_WRAPPER_GET_DIMS (SELF, LBOUNDS, UBOUNDS)
    CLASS(FIELD_4RD_WRAPPER),       INTENT(IN) :: SELF
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(OUT) :: LBOUNDS(4)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(OUT) :: UBOUNDS(4)
    IF(PRESENT(LBOUNDS))THEN
      LBOUNDS=LBOUND(SELF%PTR)
    ENDIF
    IF(PRESENT(UBOUNDS))THEN
      UBOUNDS=UBOUND(SELF%PTR)
    ENDIF
  END SUBROUTINE FIELD_4RD_WRAPPER_GET_DIMS

  SUBROUTINE FIELD_4RD_OWNER_GET_DIMS (SELF, LBOUNDS, UBOUNDS)
    CLASS(FIELD_4RD_OWNER),         INTENT(IN) :: SELF
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(OUT) :: LBOUNDS(4)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(OUT) :: UBOUNDS(4)
    IF(PRESENT(LBOUNDS))THEN
      LBOUNDS=SELF%LBOUNDS
    ENDIF
    IF(PRESENT(UBOUNDS))THEN
      UBOUNDS=SELF%UBOUNDS
    ENDIF
  END SUBROUTINE FIELD_4RD_OWNER_GET_DIMS

  SUBROUTINE FIELD_4RD_WRAPPER_RESIZE (SELF, UBOUNDS, LBOUNDS, PERSISTENT)
    CLASS(FIELD_4RD_WRAPPER),       INTENT(IN) :: SELF
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: UBOUNDS(4)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: LBOUNDS(4)
    LOGICAL, OPTIONAL,            INTENT(IN) :: PERSISTENT
    CALL ABOR1("RESIZE NOT IMPLMENTED FOR WRAPPER")
  END SUBROUTINE FIELD_4RD_WRAPPER_RESIZE

  SUBROUTINE FIELD_4RD_OWNER_RESIZE (SELF, UBOUNDS, LBOUNDS, PERSISTENT)
    CLASS(FIELD_4RD_OWNER),         INTENT(IN) :: SELF
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: UBOUNDS(4)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: LBOUNDS(4)
    LOGICAL, OPTIONAL,            INTENT(IN) :: PERSISTENT

    LOGICAL :: DELAYED
    REAL(KIND=JPRD) :: INIT_VALUE

    DELAYED=.NOT. ASSOCIATED(SELF%PTR)
    INIT_VALUE=SELF%INIT_VALUE

    CALL SELF%FINAL
    CALL SELF%INIT(UBOUNDS=UBOUNDS, LBOUNDS=LBOUNDS, PERSISTENT=PERSISTENT, DELAYED=DELAYED, INIT_VALUE=INIT_VALUE)
  END SUBROUTINE FIELD_4RD_OWNER_RESIZE


  INTEGER (KIND=JPIM) FUNCTION FIELD_4RD_GET_LAST_CONTIGUOUS_DIMENSION (PTR) RESULT (JDIM)
  REAL(KIND=JPRD), POINTER :: PTR (:,:,:,:)
  INTEGER*8 :: ISTRIDE (4)
  INTEGER (KIND=JPIM) :: J, LB(4)

  LB = LBOUND(PTR)
  ISTRIDE (1) = KIND (PTR)
  DO J = 2, 4
    ISTRIDE (J) = ISTRIDE (J-1) * SIZE (PTR, J-1)
  ENDDO

  JDIM = 0
  IF (LOC (PTR (LB(1)+1, LB(2), LB(3), LB(4))) - LOC (PTR (LB(1), LB(2), LB(3), LB(4))) /= ISTRIDE (1)) THEN
    RETURN
  ENDIF

  JDIM = 1

  IF (LOC (PTR (LB(1), LB(2)+1, LB(3), LB(4))) - LOC (PTR (LB(1), LB(2), LB(3), LB(4))) /= ISTRIDE (2)) THEN
    RETURN
  ENDIF

  JDIM = 2

  IF (LOC (PTR (LB(1), LB(2), LB(3)+1, LB(4))) - LOC (PTR (LB(1), LB(2), LB(3), LB(4))) /= ISTRIDE (3)) THEN
    RETURN
  ENDIF

  JDIM = 3

  IF (LOC (PTR (LB(1), LB(2), LB(3), LB(4)+1)) - LOC (PTR (LB(1), LB(2), LB(3), LB(4))) /= ISTRIDE (4)) THEN
    RETURN
  ENDIF

  JDIM = 4

  END FUNCTION FIELD_4RD_GET_LAST_CONTIGUOUS_DIMENSION

END MODULE FIELD_4RD_MODULE
