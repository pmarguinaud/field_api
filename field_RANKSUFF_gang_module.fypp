#! (C) Copyright 2022- ECMWF.
#! (C) Copyright 2022- Meteo-France.
#!
#! This software is licensed under the terms of the Apache Licence Version 2.0
#! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
#! In applying this licence, ECMWF does not waive the privileges and immunities
#! granted to it by virtue of its status as an intergovernmental organisation
#! nor does it submit to any jurisdiction.

MODULE FIELD_${RANK}$${SUFF}$_GANG_MODULE

#:set fieldTypeList = fieldType.getFieldTypeList (ranks=[RANK], kinds=['JP' + str (SUFF)])
#:set ft = fieldTypeList[0]

#:if ft.rank > 2

#:set fieldTypeList = fieldType.getFieldTypeList (ranks=[RANK-1], kinds=['JP' + str (SUFF)])
#:set ft1 = fieldTypeList[0]

USE FIELD_BASIC_MODULE
USE ${ft.name}$_MODULE
USE ${ft1.name}$_MODULE
USE FIELD_CONSTANTS_MODULE
USE DEV_ALLOC_MODULE

${fieldType.useParkind1 ()}$

IMPLICIT NONE

PRIVATE

#:set ftn = ft.name
#:set ftn1 = ft1.name

TYPE, EXTENDS (${ftn1}$_WRAPPER) :: ${ftn1}$_WRAPPER_HELPER
  CLASS (FIELD_BASIC), POINTER :: PARENT => NULL ()
  LOGICAL :: LFULL = .TRUE.
CONTAINS
  PROCEDURE :: DELETE_DEVICE_DATA => ${ftn1}$_DELETE_DEVICE_DATA_WRAPPER_HELPER
  PROCEDURE :: CREATE_DEVICE_DATA => ${ftn1}$_CREATE_DEVICE_DATA_WRAPPER_HELPER
  PROCEDURE :: SET_DEVICE_DIRTY => ${ftn1}$_SET_DEVICE_DIRTY_DATA_WRAPPER_HELPER
  PROCEDURE :: GET_DEVICE_DATA => ${ftn1}$_GET_DEVICE_DATA_WRAPPER_HELPER
  PROCEDURE :: GET_HOST_DATA => ${ftn1}$_GET_HOST_DATA_WRAPPER_HELPER
END TYPE

TYPE ${ftn1}$_WRAPPER_HELPER_PTR
  CLASS (${ftn1}$_WRAPPER_HELPER), POINTER :: PTR => NULL ()
END TYPE

#:for type in ['WRAPPER', 'OWNER']

TYPE, EXTENDS (${ftn}$_${type}$) :: ${ftn}$_GANG_${type}$
  TYPE (${ftn1}$_WRAPPER_HELPER_PTR), POINTER :: CHILDREN (:) => NULL ()
  LOGICAL :: LFULL = .TRUE.
CONTAINS
  PROCEDURE :: INIT_GANG => ${ftn}$_GANG_${type}$_INIT
  PROCEDURE :: FINAL => ${ftn}$_GANG_${type}$_FINAL
  PROCEDURE :: CREATE_DEVICE_DATA => ${ftn}$_GANG_${type}$_CREATE_DEVICE_DATA
  PROCEDURE :: DELETE_DEVICE_DATA => ${ftn}$_GANG_${type}$_DELETE_DEVICE_DATA
  PROCEDURE :: SET_STATUS => ${ftn}$_GANG_${type}$_SET_STATUS
  PROCEDURE :: GET_STATUS => ${ftn}$_GANG_${type}$_GET_STATUS
  PROCEDURE :: GET_DEVICE_DATA => ${ftn}$_GANG_${type}$_GET_DEVICE_DATA
  PROCEDURE :: GET_HOST_DATA => ${ftn}$_GANG_${type}$_GET_HOST_DATA
END TYPE ${ftn}$_GANG_${type}$

PUBLIC :: ${ftn}$_GANG_${type}$

#:endfor

CONTAINS

  SUBROUTINE ${ftn1}$_CREATE_DEVICE_DATA_WRAPPER_HELPER (SELF)
    CLASS(${ftn1}$_WRAPPER_HELPER) :: SELF

    IF (ASSOCIATED (SELF%PARENT)) THEN
      IF (SELF%LFULL) THEN
        CALL SELF%PARENT%CREATE_DEVICE_DATA ()
      ELSE
        CALL SELF%${ftn1}$_WRAPPER%CREATE_DEVICE_DATA ()
      ENDIF
    ENDIF

  END SUBROUTINE

  SUBROUTINE ${ftn1}$_DELETE_DEVICE_DATA_WRAPPER_HELPER (SELF)
    CLASS(${ftn1}$_WRAPPER_HELPER) :: SELF

    IF (ASSOCIATED (SELF%PARENT)) THEN
      IF (SELF%LFULL) THEN
        CALL SELF%PARENT%DELETE_DEVICE_DATA ()
      ELSE
        CALL SELF%${ftn1}$_WRAPPER%DELETE_DEVICE_DATA ()
      ENDIF
    ENDIF

  END SUBROUTINE

  SUBROUTINE ${ftn1}$_SET_DEVICE_DIRTY_DATA_WRAPPER_HELPER (SELF)

    CLASS (${ftn1}$_WRAPPER_HELPER) :: SELF

    IF (ASSOCIATED (SELF%PARENT)) THEN
      IF (SELF%LFULL) THEN
        CALL SELF%PARENT%SET_DEVICE_DIRTY ()  
      ELSE
        CALL SELF%${ftn1}$_WRAPPER%SET_DEVICE_DIRTY ()
      ENDIF
    ENDIF

  END SUBROUTINE 

#:for what in ['HOST', 'DEVICE']
  SUBROUTINE ${ftn1}$_GET_${what}$_DATA_WRAPPER_HELPER (SELF, MODE, PTR, QUEUE)
    CLASS(${ftn1}$_WRAPPER_HELPER) :: SELF
    INTEGER (KIND=JPIM),           INTENT(IN)    :: MODE
    ${ft1.type}$, POINTER,         INTENT(INOUT) :: PTR(${ft1.shape}$)
    INTEGER (KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE
    INTEGER(KIND=JPIM)                           :: LBOUNDS(${ft1.rank}$)

    IF (ASSOCIATED (SELF%PARENT)) THEN
      IF (SELF%LFULL) THEN
        IF (IAND (MODE, NWR) /= 0) THEN
          CALL SELF%PARENT%SYNC_${what}$_RDWR (QUEUE)
        ELSEIF (IAND (MODE, NRD) /= 0) THEN
          CALL SELF%PARENT%SYNC_${what}$_RDONLY (QUEUE)
        ENDIF
#:if what == 'DEVICE'
      ELSE
        CALL SELF%PARENT%CREATE_${what}$_DATA ()
#:endif
      ENDIF
    ENDIF

    CALL SELF%${ftn1}$_WRAPPER%GET_${what}$_DATA (MODE, PTR, QUEUE)

  END SUBROUTINE 

#:endfor

  SUBROUTINE ${ftn}$_GANG_WRAPPER_INIT (SELF, DATA, PERSISTENT, LBOUNDS, PARTIAL)
    CLASS(${ftn}$_GANG_WRAPPER) :: SELF
    ${ft.type}$, TARGET, INTENT(IN) :: DATA(${ft.shape}$)
    LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(${ft.rank}$)
    LOGICAL, OPTIONAL, INTENT (IN) :: PARTIAL

    LOGICAL :: LLPERSISTENT
    INTEGER (KIND=JPIM) :: IFLR, JFLD, NFLD
    INTEGER (KIND=JPIM) :: LLBOUNDS (${ft.rank}$)
    CLASS (${ftn1}$_WRAPPER_HELPER), POINTER :: YLFW

    IF (PRESENT (PARTIAL)) THEN
      SELF%LFULL = .NOT. PARTIAL
    ENDIF

    CALL SELF%${ftn}$_WRAPPER%INIT (DATA=DATA, PERSISTENT=PERSISTENT, LBOUNDS=LBOUNDS)

    LLBOUNDS = 1
    IF (PRESENT (LBOUNDS)) LLBOUNDS = LBOUNDS

    IFLR = ${ft.rank}$-1
    NFLD = SIZE (DATA, IFLR)

    LLBOUNDS(IFLR) = LLBOUNDS (IFLR+1)
    ALLOCATE (SELF%CHILDREN (NFLD))
    
#:set ar = ', '.join ([':'] * (ft.rank-2))

    DO JFLD = 1, NFLD
      ALLOCATE (YLFW)
      YLFW%LFULL = SELF%LFULL
      CALL YLFW%INIT (DATA=DATA(${ar}$, JFLD, :), PERSISTENT=PERSISTENT, LBOUNDS=LLBOUNDS(1:IFLR))
      SELF%CHILDREN (JFLD)%PTR => YLFW
      IF (SELF%LFULL) THEN
        CALL SELF%CHILDREN(JFLD)%PTR%SET_STATUS (SELF%GET_STATUS ())
      ENDIF
    ENDDO

  END SUBROUTINE ${ftn}$_GANG_WRAPPER_INIT

  SUBROUTINE ${ftn}$_GANG_OWNER_INIT(SELF, LBOUNDS, UBOUNDS, PERSISTENT, DELAYED, INIT_VALUE, PARTIAL)
    CLASS(${ftn}$_GANG_OWNER) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(${ft.rank}$)
    INTEGER(KIND=JPIM), INTENT(IN) :: UBOUNDS(${ft.rank}$)
    LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
    LOGICAL, OPTIONAL,  INTENT(IN) :: DELAYED
    ${ft.type}$, OPTIONAL, INTENT(IN) :: INIT_VALUE
    LOGICAL, OPTIONAL, INTENT (IN) :: PARTIAL

    LOGICAL :: LLPERSISTENT
    INTEGER (KIND=JPIM) :: IFLR, JFLD, NFLD
    INTEGER (KIND=JPIM) :: LLBOUNDS (${ft.rank}$)
    CLASS (${ftn1}$_WRAPPER_HELPER), POINTER :: YLFW

    IF (PRESENT (PARTIAL)) THEN
      SELF%LFULL = .NOT. PARTIAL
    ENDIF
  
    CALL SELF%${ftn}$_OWNER%INIT (PERSISTENT=PERSISTENT, LBOUNDS=LBOUNDS, UBOUNDS=UBOUNDS, DELAYED=.FALSE., INIT_VALUE=INIT_VALUE)

    LLBOUNDS = 1
    IF (PRESENT (LBOUNDS)) LLBOUNDS = LBOUNDS

    IFLR = ${ft.rank}$-1
    NFLD = UBOUNDS (IFLR)-LLBOUNDS (IFLR)+1

    LLBOUNDS(IFLR) = LLBOUNDS (IFLR+1)

    ALLOCATE (SELF%CHILDREN (NFLD))
    
#:set ar = ', '.join ([':'] * (ft.rank-2))

    DO JFLD = 1, NFLD
      ALLOCATE (YLFW)
      YLFW%LFULL = SELF%LFULL
      CALL YLFW%INIT (DATA=SELF%PTR (${ar}$, JFLD, :), PERSISTENT=PERSISTENT, LBOUNDS=LLBOUNDS(1:IFLR))
      SELF%CHILDREN (JFLD)%PTR => YLFW
      IF (SELF%LFULL) THEN
        CALL SELF%CHILDREN(JFLD)%PTR%SET_STATUS (SELF%GET_STATUS ())
      ENDIF
    ENDDO
    
  END SUBROUTINE ${ftn}$_GANG_OWNER_INIT

#:for type in ['WRAPPER', 'OWNER']
  SUBROUTINE ${ftn}$_GANG_${type}$_FINAL(SELF)
    CLASS(${ftn}$_GANG_${type}$) :: SELF
    ${ft.type}$, POINTER :: PTR(${ft.shape}$)
    INTEGER (KIND=JPIM) :: JFLD
    CLASS (${ftn1}$_WRAPPER_HELPER), POINTER :: YLF

    DO JFLD = 1, SIZE (SELF%CHILDREN)
      YLF => SELF%CHILDREN(JFLD)%PTR
      NULLIFY (YLF%DEVPTR)
      NULLIFY (YLF%PARENT)
! Mark wrapper as fresh on host, synchronization has to be handled by then parent
      CALL YLF%SET_STATUS (IOR (SELF%GET_STATUS (), NHSTFRESH))
      CALL YLF%FINAL ()
      DEALLOCATE (YLF)
    ENDDO
  
    CALL SELF%${ftn}$_${type}$%FINAL ()

    DEALLOCATE (SELF%CHILDREN)  
    NULLIFY (SELF%CHILDREN)  

  END SUBROUTINE ${ftn}$_GANG_${type}$_FINAL

  SUBROUTINE ${ftn}$_GANG_${type}$_DELETE_DEVICE_DATA(SELF)
    ! Delete the copy of this field on GPU device
    CLASS(${ftn}$_GANG_${type}$) :: SELF

    INTEGER (KIND=JPIM) :: JFLD

    IF (ASSOCIATED (SELF%DEVPTR)) THEN
      DO JFLD = 1, SIZE (SELF%CHILDREN)
        NULLIFY (SELF%CHILDREN (JFLD)%PTR%DEVPTR)
      ENDDO
      CALL DEV_DEALLOCATE (SELF%DEVPTR)
    ENDIF

  END SUBROUTINE ${ftn}$_GANG_${type}$_DELETE_DEVICE_DATA

  SUBROUTINE ${ftn}$_GANG_${type}$_CREATE_DEVICE_DATA (SELF)
    CLASS(${ftn}$_GANG_${type}$) :: SELF
    INTEGER (KIND=JPIM) :: JFLD

    CALL SELF%${ftn}$_${type}$%CREATE_DEVICE_DATA ()

#:set ar = ', '.join ([':'] * (ft.rank-2))
    DO JFLD = 1, SIZE (SELF%CHILDREN)
      SELF%CHILDREN (JFLD)%PTR%DEVPTR (${','.join (list (map (lambda i: "LBOUND(SELF%DEVPTR," + str(i) + "):", range (1, ft1.rank))))}$,1:) => SELF%DEVPTR (${ar}$, JFLD, :)
    ENDDO

  END SUBROUTINE

  SUBROUTINE ${ftn}$_GANG_${type}$_SET_STATUS (SELF, KSTATUS)
    CLASS(${ftn}$_GANG_${type}$) :: SELF
    INTEGER (KIND=JPIM), INTENT (IN) :: KSTATUS

    INTEGER (KIND=JPIM) :: JFLD

    CALL SELF%${ftn}$_${type}$%SET_STATUS (KSTATUS)

    DO JFLD = 1, SIZE (SELF%CHILDREN)
      CALL SELF%CHILDREN(JFLD)%PTR%SET_STATUS (KSTATUS)
    ENDDO

  END SUBROUTINE
  
  INTEGER (KIND=JPIM) FUNCTION ${ftn}$_GANG_${type}$_GET_STATUS (SELF)
    CLASS(${ftn}$_GANG_${type}$) :: SELF

    INTEGER (KIND=JPIM) :: JFLD
    INTEGER (KIND=JPIM) :: ISTATUS

    ISTATUS = SELF%ISTATUS

    IF (.NOT. SELF%LFULL) THEN
      ISTATUS = IOR (ISTATUS, IOR (NDEVFRESH, NHSTFRESH))
      DO JFLD = 1, SIZE (SELF%CHILDREN)
        IF (IAND (SELF%CHILDREN(JFLD)%PTR%GET_STATUS (), NDEVFRESH) == 0) THEN
          ISTATUS = IAND (ISTATUS, NOT (NDEVFRESH))
        ENDIF
        IF (IAND (SELF%CHILDREN(JFLD)%PTR%GET_STATUS (), NHSTFRESH) == 0) THEN
          ISTATUS = IAND (ISTATUS, NOT (NHSTFRESH))
        ENDIF
      ENDDO
    ENDIF

    ${ftn}$_GANG_${type}$_GET_STATUS = ISTATUS

  END FUNCTION

#:for what in ['DEVICE', 'HOST']
  SUBROUTINE ${ftn}$_GANG_${type}$_GET_${what}$_DATA (SELF, MODE, PTR, QUEUE)
    CLASS(${ftn}$_GANG_${type}$) :: SELF
    INTEGER (KIND=JPIM),           INTENT(IN)    :: MODE
    ${ft.type}$, POINTER,          INTENT(INOUT) :: PTR(${ft.shape}$)
    INTEGER (KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE

    INTEGER (KIND=JPIM) :: JFLD
    ${ft1.type}$, POINTER :: PTR1 (${ft1.shape}$)

    IF (SELF%LFULL) THEN
      CALL SELF%${ftn}$_GET_${what}$_DATA (MODE, PTR, QUEUE)
    ELSE
      DO JFLD = 1, SIZE (SELF%CHILDREN)
        CALL SELF%CHILDREN (JFLD)%PTR%GET_${what}$_DATA (MODE, PTR1, QUEUE)
      ENDDO
#:if what == 'DEVICE'
      PTR => SELF%DEVPTR
#:else
      PTR => SELF%PTR
#:endif
    ENDIF

  END SUBROUTINE 

#:endfor

#:endfor

#:endif

END MODULE FIELD_${RANK}$${SUFF}$_GANG_MODULE
